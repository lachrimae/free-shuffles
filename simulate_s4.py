from abc import ABC, abstractmethod
from itertools import permutations
from collections import defaultdict
from math import factorial
from typing import Callable
import numpy as np

import unittest
from unittest import TestCase


class Permutation:
  """
  A permutation's internal representation is a list like [0, 2, 1, 3],
  regarded as a function from the index to the value at that index.
  """

  def __init__(self, l):
    self._l = l
  
  def __call__(self, i: int) -> int:
    return self._l[i]

  def __len__(self):
    return len(self._l)
  
  def __repr__(self):
    cycles = list()
    checked_indices = set()
    while True:
      cycle = list()
      initial_index = None
      for i in range(len(self)):
        if i not in checked_indices:
          initial_index = i
          break
      if initial_index is None:
        break
      current_index = initial_index
      while True:
        checked_indices.add(current_index)
        cycle.append(current_index)
        current_index = self(current_index)
        if current_index == initial_index:
          break
      cycles.append(cycle)
    if all(map(lambda cycle: len(cycle) == 1, cycles)):
      return '()'
    s = ''
    for cycle in cycles:
      if len(cycle) == 1:
        continue
      s += '('
      for n in cycle[:-1]:
        s += str(n + 1) + ' '
      s += str(cycle[-1] + 1) + ')'
    return s

  def __mul__(self, other):
    l = list()
    for i in range(len(l)):
      l.append(self(other(i)))
    return Permutation(l)

  def __eq__(self, other):
    return self._l == other._l
  
  def __hash__(self):
    return hash(repr(self._l))

  def inv(self):
    l = [None for _ in self._l]
    for i in range(len(self._l)):
      l[self._l[i]] = i
    return Permutation(l)


class PermutationGroup:
  """Beware: this class currently has factorial space-complexity."""

  def __init__(self, n):
    self.n = n
    self._point_set = range(n)
    self._permutations = list(map(Permutation, permutations(self._point_set)))
  
  def __len__(self):
    return factorial(self.n)
  
  def __iter__(self):
    return iter(self._permutations)

  def identity(self):
    return Permutation(list(range(self.n)))


class Representation(ABC):
  def __init__(self, group):
    self.group = group

  @abstractmethod
  def degree(self) -> int:
    """The degree of the representation, as a textbook would define it."""
    pass

  @abstractmethod
  def ostensible_dimension(self) -> int:
    """If rho returns NxN matrices, this function should return the number N"""
    pass

  @abstractmethod
  def rho(self, pi: Permutation) -> np.array:
    """Returns a matrix which represents pi as an action on a vector space."""
    pass


class Trivial(Representation):
  """The trivial representation, for any group, maps all elements to the 1x1 identity matrix."""
  
  def degree(self):
    return 1

  def ostensible_dimension(self) -> int:
    return 1

  def rho(self, pi) -> np.array:
    return np.array([[1.0]])


class Sign(Representation):
  """
  If we decompose pi into transpositions, the sign representation should be +1 if it comprises
  an even number of transpositions, and -1 if it comprises an odd number.
  """

  def degree(self) -> int:
    return 1

  def ostensible_dimension(self) -> int:
    return 1
  
  def rho(self, pi) -> np.array:
    signum = 1.0
    checked_indices = set()
    while True:
      initial_index = None
      for i in range(len(pi)):
        if i not in checked_indices:
          initial_index = i
          break
      if initial_index is None:
        break
      cycle_size = 1
      current_index = initial_index
      checked_indices.add(current_index)
      while True:
        current_index = pi(current_index)
        if current_index == initial_index:
          break
        else:
          cycle_size += 1
          checked_indices.add(current_index)
      if cycle_size % 2 == 0:
        signum *= -1.0
    return np.array([[signum]])


class Standard(Representation):
  """
  The standard representation is acquired by viewing the group S_n as permuting
  basis vectors, then quotienting by the subspace generated by e_1+e_2+...+e_n.
  Currently, we don't do a proper quotient, and just use a rank-(N-1) NxN matrix.
  This works because we just care about its behaviour under the trace.
  """

  def degree(self):
    return self.group.n - 1
  
  def ostensible_dimension(self) -> int:
    return self.group.n

  def rho(self, pi) -> np.array:
    perm_mat = np.zeros([self.group.n, self.group.n])
    for i in range(len(pi)):
      perm_mat[pi(i)][i] = 1.0

    # I figured out that if you compose the appropriate change
    # of basis matrix with the matrix that maps the nth basis
    # vector to zero, you get the following matrix.
    #
    # TODO: it is not particularly clear to the reader
    # why this is correct. Fix that.
    projection = np.zeros([self.group.n, self.group.n])
    for i in range(self.group.n):
      for j in range(self.group.n):
        if i == j:
          projection[i][j] = (self.group.n - 1) / self.group.n
        else:
          projection[i][j] = -(1 / self.group.n)
    return np.matmul(projection, perm_mat)


class S4_StandardProductSign(Representation):
  """
  TODO: Maybe support products of representations more polymorphically?
  """
  def __init__(self):
    super().__init__(PermutationGroup(4))
    self.standard = Standard(self.group)
    self.sign = Sign(self.group)
  
  def degree(self) -> int:
    return 3
  
  def ostensible_dimension(self) -> int:
    return self.standard.ostensible_dimension()
  
  def rho(self, pi) -> np.array:
    standard_rho = self.standard.rho(pi)
    sign_rho = self.sign.rho(pi)[0][0]
    return sign_rho * standard_rho


class KleinQuotient(Representation):
  """
  The degree-2 representation of S4 obtained by quotienting it by the Klein 4-group
  and then composing with S3's standard representation.
  """
  def __init__(self):
    super().__init__(PermutationGroup(4))
    self.s3 = Standard(PermutationGroup(3))

  def degree(self) -> int:
    return 2
  
  def ostensible_dimension(self) -> int:
    return self.s3.ostensible_dimension()
  
  # https://groupprops.subwiki.org/wiki/Normal_V4_in_S4
  def rho(self, pi):
    # We multiply pi by every sigma in V4 in order to figure out what coset pi is in.
    for sigma in list(map(Permutation, [[0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]])):
      tau = pi * sigma
      # We can uniquely identify the coset once we find a permutation that projects
      # down to an action on the set [0, 1, 2], at which point we identify it with the element of S3
      # with the same action.
      # Off the top of my head, I'm not sure why this is true, but can verify it by eye 
      # by looking at the cosets in that wiki page^.
      if all(map(lambda x: x < 3, tau._l[:3])):
        return self.s3.rho(Permutation(tau._l[:3]))
    raise ValueError('Cannot quotient by V4 for some reason')


def pushforward(mu, representation: Representation):
  new_mu = defaultdict(lambda: 0.0)
  for pi, weight in mu.items():
    new_mu[representation.rho(pi)] += weight
  return dict(new_mu)


def is_transposition(pi: Permutation) -> bool:
  skip_index = None
  found_swap_already = False
  for i in range(len(pi)):
    if i == skip_index:
      continue
    if pi(i) != i:
      if found_swap_already:
        # more cycles than one: not a transposition
        return False
      elif pi(pi(i)) != i:
        # cycle is larger than 2: not a transposition
        return False
      else:
        found_swap_already = True
        skip_index = pi(i)
  return found_swap_already


def is_identity(pi: Permutation) -> bool:
  for i in range(len(pi)):
    if pi(i) != i:
      return False
  return True


def make_uniform_among(group, predicate: Callable[[Permutation], bool]):
  mu = {k: 0.0 for k in iter(group)}
  wanted_permutations = list(filter(predicate, iter(group)))
  support_size = len(wanted_permutations)
  if support_size == 0:
    raise ValueError('No group element passes the predicate')
  for pi in wanted_permutations:
    mu[pi] = 1.0 / support_size
  return mu


def make_random_transposition(group):
  """
  The 'random transposition' shuffle described on p.24 of
  Persi Diaconis's "Group Representations in Probability and Statistics".
  """
  mu = {k: 0.0 for k in iter(group)}
  mu[group.identity()] = 1.0 / group.n
  for pi in iter(group):
    if is_transposition(pi):
      mu[pi] = 2.0 / group.n**2
  return mu


def to_fourier(mu, representation) -> np.array:
  dim = representation.ostensible_dimension()
  res = np.zeros([dim, dim])
  for pi, weight in mu.items():
      res += weight * representation.rho(pi)
  return res


def from_fouriers(representations, mu_hat):
  scaling_factor = 1.0 / len(representations[0].group)
  def f(pi):
    accum = 0.0
    for rep in representations:
      accum += rep.degree() * np.trace(rep.rho(pi.inv()) * mu_hat(rep))
    return scaling_factor * accum
  return f


def main():
  s_3 = PermutationGroup(3)
  reps = [Trivial(s_3), Sign(s_3), Standard(s_3)]
  mu = make_random_transposition(s_3)
  
  mu_hats = [to_fourier(mu, rep) for rep in reps]
  mu_hats_squared = [mu_hat * mu_hat for mu_hat in mu_hats]

  def rep_to_mu_hat(rep):
    for i in range(3):
      if rep is reps[i]:
        return mu_hats_squared[i]
    raise ValueError

  mu_convolve_mu = from_fouriers(reps, rep_to_mu_hat)

  for pi in s_3:
    print(pi, mu_convolve_mu(pi))

  s_4 = PermutationGroup(4)
  reps = [Trivial(s_4), Sign(s_4), KleinQuotient(), Standard(s_4), S4_StandardProductSign()]
  mu = make_random_transposition(s_4)

  mu_hats = [to_fourier(mu, rep) for rep in reps]
  mu_hats_squared = [mu_hat * mu_hat for mu_hat in mu_hats]

  def rep_to_mu_hat(rep):
    for i in range(5):
      if rep is reps[i]:
        return mu_hats_squared[i]
    raise ValueError
  
  mu_convolve_mu = from_fouriers(reps, rep_to_mu_hat)
  count = 0.0
  for pi in s_4:
    count += mu_convolve_mu(pi)
    print(pi, mu_convolve_mu(pi))
  print(count)
  return


class TestSimulateS4(TestCase):
  def test_permutation_repr(self):
    x = Permutation([2,3,0,1])
    self.assertEqual(repr(x), '(1 3)(2 4)')
  
  def test_permutation_mul(self):
    x = Permutation([1, 0])
    y = x * x
    self.assertEqual(repr(y), '()')
  
  def test_permutation_inv(self):
    x = Permutation([1,2,0])
    y = x.inv()
    self.assertEqual(repr(y), '(1 3 2)')

  def test_trivial_rep(self):
    S = PermutationGroup(5)
    r = Trivial(S)
    for pi in S:
      self.assertEqual(r.rho(pi), np.array([[1.0]]))
    
  def test_sign_rep(self):
    S = PermutationGroup(5)
    r = Sign(S)
    self.assertEqual(r.rho(Permutation([1, 2, 0, 4, 3])), np.array([[-1.0]]))

  def test_standard_rep(self):
    S = PermutationGroup(3)
    r = Standard(S)
    self.assertEqual(np.trace(r.rho(PermutationGroup(3).identity())), 2)

  def test_is_transposition(self):
    self.assertTrue(is_transposition(Permutation([0, 2, 1])))
    self.assertFalse(is_transposition(Permutation([1, 2, 0])))

  def test_to_fourier(self):
    S = PermutationGroup(5)
    r = Standard(S)
    mu = make_uniform_among(S, lambda x: True)
    mu_hat = to_fourier(mu, r)
    for row in mu_hat:
      for entry in row:
        self.assertAlmostEqual(entry, 0.0)

  # TODO: test_from_fourier

  # TODO: extract the stuff on S3 and S4 from main()
  # and make those into tests
  def test_main(self):
    main()

if __name__ == '__main__':
  unittest.main()